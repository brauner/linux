Another restriction we're going to need for MOVE_MOUNT_T_REPLACE is that the
target mount point must actually be a mountpoint. IOW, if you have:

mount /dev/sda1 /mnt
mkdir /mnt/target
mount-replace /dev/sda2 /mnt/target

then this would fail with -EINVAL becaseu /mnt/target isn't a mountpoint.

Notes on mount semantics with mount propagation:

Consider two mount namespaces. The host mount namespace is shared. A first
mount namespace is created which is a dependent ("slave") mount namespace. IOW,
mount events propagate from the host mount namespace into the first mount
namespace but not vica versa.

We create a mount in the host mount namespace

  mount --bind /opt /mnt

which propagates into the first mount namespace. We create a mount in the first
mount namespace:

  mount --bind /tmp /mnt

This mount only appears in the first mount namespace and doesn't propagate to
the host mount namespace.

We unmount /mnt in the host mount namespace. This will undo:

  mount --bind /opt /mnt

from above in the host mount namespace. However, in the first mount namespace
the second mount

  mount --bind /tmp /mnt

will stick around. IOW, the stacked upon mount is unmounted while the top mount
isn't.

Now consider a case where the mounted on dentry is provided is exclusively
provided by the stacked upon mount. In the host mount namespace we do:

  mkdir /opt/mntpt
  mount --bind /opt /mnt

and in the first mount namespace we do:

  mount --bind /tmp /mnt/mntpt

We know unmount /mnt in the host mount namespace which undoes:

  mount --bind /opt /mnt

This time the umount will not propagate into the first mount namespace. IOW,
the stacked upon and the top mount both stick around as the mountpoint of the
top mount is provided exclusively by the stacked upon mount.

Now we unlink /opt/mntpt in the host mount namespace:

  rmdir /opt/mntpt

now the stacked upon as well as the top mount are unmounted in the first mount
namespace. The reason is that during file or directory removal the VFS will
detach the mounts that other mount namespaces have stacked upon the file or
directory.

This is an interesting semantic tidbit, as it means if you want to make sure
that /opt/mntpt isn't used as a mountpoint anymore in any other mount namespace
you should unlink it as it will detach all mounts stacked upon it in other
mount namespaces that don't propagate mount events into your mount namespace.

/* Issues */

The current implementation seems to have a bug:

  mount --bind /opt /mnt
  mount --replace /tmp /mnt

is supposed to replace the mount of "/opt" at "/mnt" with the mount of "/tmp"
at "/mnt". My thinking had been that this can simply be implemented as:

  do_move_mount(@from_path->mnt[/tmp], @to_path->mnt[/mnt[opt]]);

where "/tmp" is mounted on top of "/mnt", followed by:

  umount_tree(&to_path->mnt[/mnt[opt]], UMOUNT_PROPAGATE);

which would unmount "/opt" on top of "/mnt" and only leave "/tmp" on top of
"/mnt" around.

However, this implementation doesn't seem to work as:

  umount_tree(&to_path->mnt[/mnt[opt]], UMOUNT_PROPAGATE);

unmounts both "/opt" and "/tmp" on top of "/mnt".

To debug this we can remove UMOUNT_PROPAGATE from the umount_tree() call in
which case we can see that while:

  mount --bind /opt /mnt
  mount --replace /tmp /mnt

is _supposed to mean_ that "/tmp" will be mounted on top of "/mnt" and "/opt"
will be unmounted what happens is that "/tmp" is mounted on "/opt" and "/opt"
is unmounted from "/mnt".

We can further debug this by realizing that MOVE_MOUNT_T_REPLACE is currently
implemented as:

  1. mount on top of target
  2. unmount mount the mount that is now below the just created mount in 1.

What this means we can see in userspace:

  mount --bind /opt /mnt
  mount --bind /tmp /mnt

If "/opt" on top of "/mnt" is a shared mount then the next mount of "/tmp" on
top of "/mnt" will cause the "/tmp" mount to propagate to "/opt" itself and we
end up with the following mount table:

  ├─/mnt                                        /dev/sda2[/opt] ext4       rw,relatime
  │ └─/mnt                                      /dev/sda2[/tmp] ext4       rw,relatime
  ├─/opt                                        /dev/sda2[/tmp] ext4       rw,relatime

Consequently if userspace unmounts "/tmp" via the "/opt" mountpoint:

  umount /opt

this will unmount "/tmp" from "/opt". Then the unmount will propagate to the
mount of "/tmp" on the "/mnt" mountpoint. IOW, the "/tmp" mount is unmounted
from both the "/mnt" and "/opt" mountpoint.

Similarly, if userspace unmounts "/tmp" via the "/mnt" mountpoint this will
first unmount "/tmp" from "/mnt". Then the umount will propagate to the mount
of "/tmp" on the "/opt" mountpoint. IOW, the "/tmp" mount is unmounted from
both the "/opt" and "/mnt" mountpoints.

So no matter where we unmount the top "/tmp" mount from, it will always
propagate the unmount if the first mount on top of "/mnt" was shared
(mount --make-private /opt or mount --make-private /mnt won't change this after
 the fact).

So a unmount of either via "/opt" or "/mnt" mountpoint will always kill both
"/tmp" mounts:

  │ └─/mnt                                      /dev/sda2[/tmp] ext4       rw,relatime
  ├─/opt                                        /dev/sda2[/tmp] ext4       rw,relatime

However, things look different when the first mount is a private mount:

  mount --bind /opt /mnt
  mount --make-private /mnt
  mount --bind /tmp /mnt

which means that the a mount of "/tmp" via the "/mnt" mountpoint will only
stack the "/tmp" mount on top of the "/opt" mount on the "/mnt" mountpoint. The
"/tmp" mount will not be propagated to the "/opt" mountpoint:

  ├─/mnt                                        /dev/sda2[/opt] ext4       rw,relatime
  │ └─/mnt                                      /dev/sda2[/tmp] ext4       rw,relatime

Consequently, an unmount of the "/tmp" mount via the "/mnt" mountpoint doesn't
have to propagate anywhere.

After this mount propagation detour we should be able to better understand why
the current implementation:

  1. mount on top of target
  2. unmount mount the mount that is now below the just created mount in 1.

doesn't work.

If the first mount of "/opt" on top of the "/mnt" mountpoint is a shared mount
and we ask the kernel to replace the "/opt" mount on the "/mnt" mountpoint with
a "/tmp" mount:

  mount --bind /opt /mnt
  mount --replace /tmp /mnt

then the current implementation causes the layout explained above:

  ├─/mnt                                        /dev/sda2[/opt] ext4       rw,relatime
  │ └─/mnt                                      /dev/sda2[/tmp] ext4       rw,relatime
  ├─/opt                                        /dev/sda2[/tmp] ext4       rw,relatime

and then we call umount_tree() on the "/opt" vfsmount mounted on "/mnt". At the
start of umount_tree() it will select both the "/opt" and "/tmp" vfsmounts for
unmounting. The "/opt" vfsmount is mounted at the mount->mnt_mountpoint["/mnt"]
while the "/tmp" vfsmount is mounted at the mount->mnt_mountpoint["/opt"]
mountpoint. The reason for this is simply that the two mounts are stacked.

The stacking means that the "/tmp" mount is a child of the "/opt" mount:

  mount["/opt"] {
          .mnt["/opt"]
          .mnt_mountpoint["/mnt"]
  }
  \
   mount["/tmp"] {
           .mnt["/tmp"]
           .mnt_mountpoint["/opt"]
   }

with mount["/tmp"] ending up on mount["/opt"]->mnt_mounts list of children. In
other words, since mount["/tmp"] is a child of mount["/opt"] unmounting
mount["/opt"] will also unmount mount["/tmp"].

This also explains why all mounts go away when the "/opt" vfsmount is unmounted
from the "/mnt" mountpoint. Since the separate "/tmp" vfsmount on the "/opt"
mountpoint was created by mount propagation during

  mount --bind /tmp /mnt

any unmount of the "/tmp" vfsmount from either mountpoint (see above) will
cause both mounts to be unmounted.
